# ç®€ä»‹

ä¸ºäº†æ›´æ–¹ä¾¿åŸ¹è®­æ–°åŒäº‹å¦‚ä½•é’ˆå¯¹å·²æœ‰æ•°æ®è®­ç»ƒå¹¶é¢„æµ‹ï¼Œæ‰€ä»¥è®°å½•äºæ­¤ï¼Œæ–¹ä¾¿åç»­ä½¿ç”¨ã€‚
æœ¬æ–‡ä¼šæ ¹æ®ä½ç»´åº¦ç‰¹å¾æ•°æ®è¿›è¡Œåˆ†ç±»é¢„æµ‹ï¼ŒåŒ…å«æ•°æ®åˆ†æã€ç‰¹å¾å·¥ç¨‹ã€æ•°æ®é¢„å¤„ç†ã€æ•°æ®é›†åˆ’åˆ†ã€æ¨¡å‹è®­ç»ƒã€æ¨¡å‹è¯„ä¼°ã€æ¨¡å‹é¢„æµ‹ã€æ¨¡å‹ä¿å­˜ã€æ¨¡å‹åŠ è½½ã€æ¨¡å‹é¢„æµ‹ç­‰æ­¥éª¤ã€‚
å¦‚æœæœ‰ä¸åˆé€‚æˆ–è€…é”™è¯¯ï¼Œæ¬¢è¿æå‡ºã€‚

å†œä½œç‰©è‚¥æ–™é¢„æµ‹ æ•°æ®æºæ¥è‡ªkaggleæ¯”èµ›ï¼Œé“¾æ¥å¦‚ä¸‹ï¼šhttps://www.kaggle.com/competitions/playground-series-s5e6/data

## åˆ†ç±»é¢„æµ‹æµç¨‹

### 1. æ‰¾åˆ°ç›®æ ‡

å¦‚æœæ˜¯æ¯”èµ›ï¼Œé‚£ä¹ˆç›´æ¥çœ‹ç›®æ ‡å°±è¡Œäº†ï¼Œå¦‚æœä¸æ˜¯æ¯”èµ›ï¼Œé‚£ä¹ˆä½ éœ€è¦æ ¹æ®ä½ å®é™…çš„åœºæ™¯å»ç¡®å®šä¸€ä¸ªç›®æ ‡ã€‚å› ä¸ºé€šå¸¸æ¥è®²æˆ‘ä»¬éƒ½æ˜¯æƒ³è¦å®ç°æŸä¸ªç›®æ ‡ï¼Œç„¶åæ‰ä¼šé‡‡é›†ç›¸åº”çš„æ•°æ®ã€‚
ï¼ˆå½“ç„¶ï¼Œåè¿‡æ¥å·²ç»æœ‰äº†ä¸€å¤§æ¨æ•°æ®ï¼Œæˆ‘ä»¬æƒ³è¦æ ¹æ®è¿™äº›æ•°æ®å»æ‰¾åˆ°äººç±»æ„ŸçŸ¥ä¸åˆ°çš„ä¸€äº›è”ç³»ï¼Œè¿™åˆæ˜¯å¦ä¸€ç äº‹äº†ã€‚ï¼‰
æ ¹æ®æ¯”èµ›çš„è¦æ±‚ï¼Œæˆ‘ä»¬çš„ç›®æ ‡ä¸ºï¼šæ ¹æ®ä¸åŒçš„å¤©æ°”ã€åœŸå£¤æ¡ä»¶å’Œä½œç‰©é€‰æ‹©æœ€å¥½çš„è‚¥æ–™ã€‚

### 2. æ•°æ®åˆ†æ

æˆ‘ä»¬é€šè¿‡å¯¹æ•°æ®é›†çš„æŸ¥çœ‹å¯ä»¥å¾—åˆ°æ•°æ®é›†å¦‚ä¸‹ï¼š
æ¸©åº¦ã€æ¹¿åº¦ã€æ°´åˆ†ã€æ°®ã€ç£·ã€é’¾ã€å†œä½œç‰©ç±»å‹ã€åœŸå£¤ç±»å‹ã€è‚¥æ–™åç§°ï¼ˆç›®æ ‡ï¼‰
å…¶ä¸­é™¤äº†Soil Typeã€Crop Typeã€ Fertilizer Nameè¿™3ä¸ªå­—æ®µæ˜¯objectç±»å‹ï¼Œå…¶ä»–å­—æ®µçš„æ•°æ®ç±»å‹éƒ½æ˜¯æ•°å­—ç±»å‹ã€‚ 
åˆ†ç±»ç›®æ ‡æ˜¯Fertilizer Nameï¼Œæˆ‘ä»¬éœ€è¦å¯¹å…¶è¿›è¡Œé¢„æµ‹ã€‚ 
è®­ç»ƒæ•°æ®é›†çš„å­—æ®µå¦‚ä¸‹ï¼š

| å­—æ®µåç§°         | `id`            | `Temparature` | `Humidity` | `Moisture` | `Soil Type` | `Crop Type` | `Nitrogen` | `Phosphorous` | `Potassium` | `Fertilizer Name` |
|------------------|-----------------|---------------|------------|------------|-------------|-------------|------------|----------------|-------------|-------------------|
| **å­—æ®µæè¿°**     | æ ·æœ¬ç¼–å·        | æ¸©åº¦          | æ¹¿åº¦       | æ°´åˆ†       | åœŸå£¤ç±»å‹    | ä½œç‰©ç±»å‹    | æ°®         | ç£·             | é’¾          | è‚¥æ–™åç§°          |

æ•°æ®åˆ†æé‡Œé¢çš„å†…å®¹æœ‰å¾ˆå¤šï¼Œæ¯”å¦‚æŸ¥çœ‹æ•°æ®çš„ç¼ºå¤±å€¼ã€æŸ¥çœ‹æ•°æ®çš„åˆ†å¸ƒã€æŸ¥çœ‹æ•°æ®çš„ç›¸å…³æ€§ã€æŸ¥çœ‹æ•°æ®çš„å¼‚å¸¸å€¼ã€æŸ¥çœ‹æ•°æ®çš„åˆ†å¸ƒç­‰ç­‰ã€‚
è¿™é‡Œåªåšä¸€äº›ç®€å•çš„åˆ†æï¼Œæä¾›ä¸‹ç¤ºä¾‹ä»£ç ã€‚

æ•°æ®é›†åŸºç¡€åˆ†æï¼šæŸ¥çœ‹å‰å‡ è¡Œæ•°æ®ï¼Œè¡Œæ•°ï¼Œç»Ÿè®¡ç»“æœç®€è¿°
```python
def basic_info():
    '''
    æ•°æ®é›†åŸºç¡€åˆ†æ
    :return:
    '''
    # æŸ¥çœ‹å‰å‡ è¡Œæ•°æ®
    print("--æŸ¥çœ‹å‰å‡ è¡Œæ•°æ® --")
    print(df_train.head())

    # æŸ¥çœ‹æ•°æ®åŸºæœ¬ä¿¡æ¯ï¼ˆç¼ºå¤±å€¼ã€æ•°æ®ç±»å‹ç­‰ï¼‰
    print("--æŸ¥çœ‹æ•°æ®åŸºæœ¬ä¿¡æ¯ --")
    print(df_train.info())

    # ç»Ÿè®¡æè¿°ï¼ˆé’ˆå¯¹æ•°å€¼å‹å­—æ®µï¼‰
    print("--ç»Ÿè®¡æè¿° --")
    # æ˜¾ç¤ºå®Œæ•´çš„æè¿°ç»Ÿè®¡ç»“æœï¼Œä¸è¿›è¡Œæˆªæ–­
    pd.set_option('display.max_columns', None)
    print(df_train.describe())

    # æ¢å¤åˆ—æ˜¾ç¤ºé™åˆ¶ï¼ˆå¯é€‰ï¼‰
    pd.reset_option('display.max_columns')
```
ç»˜åˆ¶æ•°æ®ç±»å‹ç›´æ–¹å›¾
```python
def plot_numeric_histograms():
    try:
        # è·å–æ•°å€¼å‹åˆ—ååˆ—è¡¨
        numeric_cols = df_train.select_dtypes(include=[np.number]).columns.tolist()

        # è®¾ç½®å›¾å½¢å¸ƒå±€å‚æ•°
        ncols = 2
        nrows = (len(numeric_cols) + 1) // 2

        fig, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize=(15, 10))
        print("å¼€å§‹ç»˜åˆ¶ç›´æ–¹å›¾")

        for i, col in enumerate(numeric_cols):
            try:
                row, col_idx = divmod(i, ncols)
                sns.histplot(df_train[col], ax=axes[row, col_idx], kde=True)
            except Exception as e:
                print(f"ç»˜åˆ¶åˆ— {col} å‡ºé”™: {e}")

        # éšè—å¤šä½™çš„å­å›¾
        for j in range(i + 1, nrows * ncols):
            row, col_idx = divmod(j, ncols)
            fig.delaxes(axes[row, col_idx])

        plt.tight_layout()
        plt.show()  # æ˜¾ç¤ºå›¾åƒ
        plt.close()  # å…³é—­å›¾åƒèµ„æºï¼Œé¿å…å†…å­˜å ç”¨è¿‡é«˜
    except Exception as e:
        print(f"ç»˜åˆ¶ç›´æ–¹å›¾å‡ºé”™: {e}")
```
ç»˜åˆ¶å¯¹è±¡ç±»å‹ç®±çº¿å›¾
```python
def plot_categorical_histograms():
    # æå–ç±»åˆ«å‹åˆ—
    categorical_cols = df_train.select_dtypes(include=['object']).columns.tolist()
    soil_types = df_train['Soil Type'].unique()
    crop_types = df_train['Crop Type'].unique()
    print("soil_types:", soil_types)
    print("crop_types:", crop_types)

    # è®¾ç½®å›¾å½¢å¸ƒå±€å‚æ•°
    ncols = 2
    nrows = (len(categorical_cols) + 1) // 2

    fig, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize=(15, 10))
    print("å¼€å§‹ç»˜åˆ¶ç±»åˆ«å‹åˆ—åˆ†å¸ƒ")

    # éå†æ‰€æœ‰ç±»åˆ«å‹åˆ—å¹¶ç»˜å›¾
    for i, col in enumerate(categorical_cols):
        try:
            row, col_idx = divmod(i, ncols)  # ä¿®å¤ï¼šä½¿ç”¨ ncols è€Œä¸æ˜¯ col
            sns.countplot(data=df_train, x=col, ax=axes[row, col_idx])
            axes[row, col_idx].set_title(f'Count Plot of {col}')
            axes[row, col_idx].tick_params(axis='x', rotation=45)  # é˜²æ­¢æ ‡ç­¾é‡å 
            print("{col}",col)
        except Exception as e:
            print(f"ç»˜åˆ¶åˆ— {col} å‡ºé”™: {e}")

    # éšè—å¤šä½™çš„å­å›¾
    for j in range(i + 1, nrows * ncols):
        row, col_idx = divmod(j, ncols)
        fig.delaxes(axes[row, col_idx])

    plt.tight_layout()
    plt.show()
    plt.close()  # å…³é—­å›¾åƒèµ„æºï¼Œé¿å…å†…å­˜å ç”¨è¿‡é«˜
```
æ•°å€¼ç±»å‹æ•°æ®targetå æ¯”
```python
def feature_distribution_by_target():
    '''
    æ•°å€¼ç±»å‹æ•°æ®targetå æ¯”
    :return:
    '''
    # ç­›é€‰æ•°å€¼å‹åˆ—ï¼ˆæ’é™¤ object ç±»å‹ï¼‰
    numeric_cols = df_train.select_dtypes(include=[np.number]).columns.tolist()

    # æ˜ç¡®æ’é™¤ 'id' å’Œç›®æ ‡åˆ—ï¼ˆå¦‚æœæœ‰ï¼‰
    if 'id' in numeric_cols:
        numeric_cols.remove('id')

    # æ’é™¤å¯èƒ½åŒ…å«çš„ç›®æ ‡åˆ—æœ¬èº«ï¼ˆå¦‚æœæœ‰ï¼‰
    if 'Fertilizer Name' in numeric_cols:
        numeric_cols.remove('Fertilizer Name')
    # æŒ‰ç›®æ ‡å˜é‡åˆ†ç»„å¹¶è®¡ç®—å‡å€¼
    grouped = df_train.groupby('Fertilizer Name')[numeric_cols].mean()

    # æ‰“å°è¡¨æ ¼å½¢å¼çš„ç»Ÿè®¡ç»“æœ
    print("\nä¸åŒ Fertilizer Name ä¸‹å„æ•°å€¼ç‰¹å¾çš„å¹³å‡å€¼ï¼š")
    print(grouped)

    # ç»˜åˆ¶çƒ­åŠ›å›¾ï¼ˆHeatmapï¼‰ï¼Œå±•ç¤ºä¸åŒç±»åˆ«ä¸‹ç‰¹å¾å‡å€¼çš„å·®å¼‚
    plt.figure(figsize=(14, 10))
    sns.heatmap(grouped.T, annot=True, cmap='coolwarm', fmt='.2f')
    plt.title('å¹³å‡å€¼ Heatmap')
    plt.tight_layout()
    plt.show()
    plt.close()

    # å¯é€‰ï¼šç»˜åˆ¶æ¯ä¸ªç‰¹å¾çš„æŸ±çŠ¶å›¾ï¼Œæ˜¾ç¤ºä¸åŒç±»åˆ«çš„å‡å€¼
    for col in numeric_cols:
        plt.figure(figsize=(12, 6))
        sns.barplot(x='Fertilizer Name', y=col, data=df_train, estimator=np.mean, ci=None)
        plt.xticks(rotation=45)
        plt.title(f'Mean {col} by Fertilizer Name')
        plt.tight_layout()
        plt.show()
        plt.close()
    # æŸ¥çœ‹objectç±»å‹çš„æ•°æ®
```
æŸ¥çœ‹æ•°å€¼ç±»å‹çš„æ•°æ®åˆ†å¸ƒ
```python
def categorical_distribution_by_target():
    '''
    æŸ¥çœ‹æ•°æ®ç±»å‹çš„æ•°æ®åˆ†å¸ƒ
    :return:
    '''
    # æå–ç±»åˆ«å‹åˆ—ï¼ˆæ’é™¤ 'id' å’Œç›®æ ‡åˆ—ï¼‰
    categorical_cols = df_train.select_dtypes(include=['object']).columns.tolist()
    if 'id' in categorical_cols:
        categorical_cols.remove('id')
    if 'Fertilizer Name' in categorical_cols:
        categorical_cols.remove('Fertilizer Name')

    target_col = 'Fertilizer Name'

    for col in categorical_cols:
        # åˆ›å»ºäº¤å‰è¡¨
        cross_tab = pd.crosstab(df_train[target_col], df_train[col], normalize='index')

        # ç»˜åˆ¶å †å æŸ±çŠ¶å›¾
        cross_tab.plot(kind='bar', stacked=True, figsize=(12, 6))
        plt.title(f'Distribution of {col} by Fertilizer Name (Normalized)')
        plt.xlabel('Fertilizer Name')
        plt.ylabel(f'Relative Frequency of {col}')
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.legend(title=col)
        plt.show()
        plt.close()

```
æŸ¥çœ‹ç›®æ ‡å€¼ç§ç±»åŠå…¶æ•°é‡
```python
def target_column_analysis():
    # æŸ¥çœ‹è‚¥æ–™ç§ç±»åŠå…¶æ•°é‡
    print(df_train['Fertilizer Name'].value_counts())

    # å¯è§†åŒ–ç›®æ ‡å˜é‡åˆ†å¸ƒ
    sns.countplot(y='Fertilizer Name', data=df_train, order=df_train['Fertilizer Name'].value_counts().index)
    plt.title('Distribution of Fertilizer Names')
    plt.tight_layout()
    plt.show()
```
### 3. ç‰¹å¾å·¥ç¨‹

æˆ‘ä»¬ä½¿ç”¨äººå·¥æ™ºèƒ½è‚¯å®šæ˜¯ä¸ºäº†è§£å†³ç°å®ä¸­çš„é—®é¢˜ï¼Œå…¶å®å¾ˆå¤šç‹¬ç«‹çš„æ•°æ®æ˜¯æœ‰ç€å¿…ç„¶çš„å…³è”çš„ï¼Œè¿™å°±éœ€è¦ä¸€äº›å…ˆéªŒçš„çŸ¥è¯†ã€‚
æœ¬æ¬¡æ˜¯åœŸå£¤æ–½è‚¥çš„é—®é¢˜ï¼Œé‚£æˆ‘ä»¬å°±æŒ‰ç…§è¿™ä¸ªä¸¾ä¾‹å­æ¥è¿›è¡Œç‰¹å¾å·¥ç¨‹ã€‚
1. æ°®(N)ã€ç£·(P)å’Œé’¾(K)æ˜¯æ¤ç‰©ç”Ÿé•¿æ‰€å¿…éœ€çš„ä¸»è¦è¥å…»å…ƒç´ ï¼Œå®ƒä»¬åœ¨åœŸå£¤ä¸­çš„æ€»å«é‡å¯ä»¥åæ˜ åœŸå£¤è‚¥åŠ›çš„æ•´ä½“æ°´å¹³ã€‚
2. æ¸©åº¦(Temparature)å’Œæ¹¿åº¦(Humidity)æ˜¯å½±å“æ¤ç‰©ç”Ÿé•¿çš„é‡è¦å› ç´ ï¼Œå®ƒä»¬çš„ç»„åˆå¯ä»¥åæ˜ åœŸå£¤çš„æ¸©åº¦å’Œæ¹¿åº¦ç‰¹æ€§ã€‚
3. æ°´åˆ†(Moisture)æ˜¯æ¤ç‰©ç”Ÿé•¿è¿‡ç¨‹ä¸­ä¸å¯æˆ–ç¼ºçš„ä¸€ä¸ªå› ç´ ï¼Œå®ƒå¯ä»¥åæ˜ åœŸå£¤çš„æ°´åˆ†å«é‡ã€‚
4. åœŸå£¤ç±»å‹(Soil Type)å’Œä½œç‰©ç±»å‹(Crop Type)æ˜¯å½±å“æ¤ç‰©ç”Ÿé•¿çš„é‡è¦å› ç´ ï¼Œå®ƒä»¬çš„ç»„åˆå¯ä»¥åæ˜ åœŸå£¤å’Œä½œç‰©çš„ç‰¹æ€§ã€‚
5. ç­‰ç­‰
 è¿™é‡Œæ˜¯ä¸¾ä¾‹è¯´æ˜çš„ä¸€ç§ç‰¹å¾å·¥ç¨‹ï¼Œå®é™…ä¸­å¯èƒ½å­˜åœ¨æ›´å¤šçš„ç‰¹å¾ï¼Œè€Œä¸”æ„å»ºç‰¹å¾ä»¥åè¿˜éœ€è¦shapåˆ†æç­‰æ“ä½œï¼Œ
ç„¶åå†å›å¤´æ”¹è¿›ç‰¹å¾å·¥ç¨‹ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ªç¯è¿­ä»£çš„è¿‡ç¨‹ï¼Œå¾€å¾€ä¸å¯èƒ½ä¸€æ¬¡å°±èƒ½å¤Ÿæ»¡è¶³éœ€æ±‚ã€‚æ‰€ä»¥æ•°æ®åˆ†æåŸºæœ¬ä¸Šæ˜¯è´¯ç©¿å…¨å±€çš„ï¼Œ
ä¸ä»…ä»…æ˜¯â€œè°ƒå‚ä¾ â€è¿˜éœ€è¦æ‰å®çš„åŸºç¡€æ‰èƒ½è®©ä½ æ•´åˆåçš„æ•°æ®ç¬¦åˆæœŸæœ›æ•ˆæœã€‚
```python
import numpy as np
# -----------------------------
# ç‰¹å¾æ„é€ 
# -----------------------------
def add_agricultural_features(df):
    """
    æ„é€ å†œä¸šé¢†åŸŸç›¸å…³ç‰¹å¾
    """
    df['NPK_Sum'] = df['Nitrogen'] + df['Phosphorous'] + df['Potassium']
    df['N_P_Ratio'] = df['Nitrogen'] / (df['Phosphorous'] + 1e-5)
    df['P_K_Ratio'] = df['Phosphorous'] / (df['Potassium'] + 1e-5)
    df['Env_Index'] = df['Temparature'] * df['Humidity'] * df['Moisture']
    df['Fertility_Score'] = (
            df['Nitrogen'] * 0.3 +
            df['Phosphorous'] * 0.3 +
            df['Potassium'] * 0.4
    )
    crop_n_preference = {
        'Wheat': 0.8,
        'Maize': 0.7,
        'Oil seeds': 0.3,
        'Paddy': 0.5,
        'Cotton': 0.6,
        'Barley': 0.7,
        'Millets': 0.5,
        'Sugarcane': 0.4,
        'Ground Nuts': 0.4,
        'Tobacco': 0.5,
        'Pulses': 0.4
    }
    df['Crop_Nitrogen_Preference'] = df['Crop Type'].map(crop_n_preference).fillna(0.5)
    df['Weighted_N'] = df['Nitrogen'] * df['Crop_Nitrogen_Preference']
    df['N_sqrt'] = np.sqrt(df['Nitrogen'])
    df['NK_ratio'] = df['Nitrogen'] / (df['Potassium'] + 1e-5)
    return df

```

æŸ¥çœ‹çƒ­åŠ›å›¾åŠshapåˆ†æå“ªä¸ªå…ƒç´ å½±å“å¤§
```python
def plot_feature_vs_target(df, target_col):
    """
    ç»˜åˆ¶ç›®æ ‡åˆ—ä¸æ‰€æœ‰æ•°å€¼å‹ç‰¹å¾ä¹‹é—´çš„å…³ç³»å›¾

    å‚æ•°:
        df (pd.DataFrame): æ•°æ®æ¡†
        target_col (str): ç›®æ ‡åˆ—åç§°ï¼ˆå¦‚ 'Fertilizer Name'ï¼‰
    """
    # æ£€æŸ¥ç›®æ ‡åˆ—æ˜¯å¦å­˜åœ¨
    if target_col not in df.columns:
        raise ValueError(f"ç›®æ ‡åˆ— '{target_col}' ä¸å­˜åœ¨äº DataFrame ä¸­")

    # è®¾ç½®ç»˜å›¾é£æ ¼
    sns.set(style="whitegrid")

    # ç±»åˆ«åˆ†å¸ƒå›¾
    plt.figure(figsize=(10, 6))
    sns.countplot(x=target_col, data=df, palette="Set2")
    plt.title(f'{target_col} ç±»åˆ«åˆ†å¸ƒ')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

    # æ•°å€¼å‹ç‰¹å¾ä¸ç›®æ ‡çš„å…³ç³»å›¾
    for col in df.columns:
        if col != target_col and df[col].dtype != 'object':
            plt.figure(figsize=(10, 6))
            sns.boxplot(x=target_col, y=col, data=df, palette="Set3")
            plt.title(f'{col} vs {target_col}')
            plt.xticks(rotation=45)
            plt.tight_layout()
            plt.show()
def generate_data_report(df, target_col='Fertilizer Name'):
    """
    ç”Ÿæˆå®Œæ•´çš„æ•°æ®æ¢ç´¢æŠ¥å‘Šï¼š
        - ç±»åˆ«åˆ†å¸ƒå›¾
        - æ¯ä¸ªæ•°å€¼ç‰¹å¾åœ¨ä¸åŒç±»åˆ«ä¸‹çš„åˆ†å¸ƒï¼ˆboxplotï¼‰
        - ä½¿ç”¨XGBoost + SHAPè¿›è¡Œç‰¹å¾é‡è¦æ€§åˆ†æ
    """
    print("ğŸ“Š å¼€å§‹ç”Ÿæˆæ•°æ®æ¢ç´¢æŠ¥å‘Š...")

    # 1. ç»˜åˆ¶ç›®æ ‡åˆ—ä¸å„æ•°å€¼ç‰¹å¾çš„å…³ç³»å›¾
    # plot_feature_vs_target(df, target_col)

    # 2. æ„å»ºè®­ç»ƒé›†å¹¶è®­ç»ƒè½»é‡æ¨¡å‹ç”¨äºç‰¹å¾é‡è¦æ€§åˆ†æ
    print("ğŸ§  è®­ç»ƒXGBoostæ¨¡å‹ä»¥è¯„ä¼°ç‰¹å¾é‡è¦æ€§...")
    y = df['Fertilizer Name'].values
    # ç¼–ç æ ‡ç­¾ï¼ˆè™½ç„¶ä½ å·²å¤„ç†è¿‡ï¼Œä½†ç¡®ä¿æ˜¯æ•´æ•°å½¢å¼ï¼‰
    le = LabelEncoder()
    y = le.fit_transform(y)

    X_train, X_val, y_train, y_val = train_test_split(
        df.drop(columns=[target_col]),
        y,
        test_size=0.2,
        random_state=42
    )

    # æ•°æ®é¢„å¤„ç†
    numeric_features = X_train.select_dtypes(include=['number']).columns.tolist()
    categorical_features = X_train.select_dtypes(include=['object']).columns.tolist()

    preprocessor = ColumnTransformer([
        ('num', StandardScaler(), numeric_features),
        ('cat', OneHotEncoder(handle_unknown='ignore'), categorical_features)
    ])

    X_train_processed = preprocessor.fit_transform(X_train)
    X_val_processed = preprocessor.transform(X_val)

    # è®­ç»ƒè½»é‡æ¨¡å‹
    model = XGBClassifier(
        n_estimators=200,
        max_depth=5,
        learning_rate=0.1,
        subsample=0.8,
        colsample_bytree=0.7,
        random_state=42
    )
    model.fit(X_train_processed, y_train)

    # 3. ç‰¹å¾é‡è¦æ€§å¯è§†åŒ–ï¼ˆSHAPï¼‰
    print("ğŸ” ç”Ÿæˆç‰¹å¾é‡è¦æ€§å›¾è¡¨...")
    explainer = shap.TreeExplainer(model)
    try:
        shap_values = explainer.shap_values(X_train_processed)

        # å¦‚æœæ˜¯å¤šåˆ†ç±»ä»»åŠ¡ï¼Œå–ç¬¬ä¸€ä¸ªç±»åˆ«çš„ SHAP å€¼
        if isinstance(shap_values, list):
            shap_values = shap_values[0]

        # ç¡®ä¿ X_train æ˜¯ç¨ å¯†æ•°ç»„
        if hasattr(X_train_processed, "toarray"):
            X_train_dense = X_train_processed.toarray()
        else:
            X_train_dense = X_train_processed

        # è·å–æ­£ç¡®çš„ç‰¹å¾åç§°
        def get_transformed_column_names(preprocessor, numeric_features, categorical_features):
            transformers = []
            for name, trans, cols in preprocessor.transformers_:
                if trans == 'drop':
                    continue
                if name == 'cat':
                    new_cols = preprocessor.named_transformers_['cat'].get_feature_names_out(categorical_features)
                    transformers.extend(new_cols)
                else:
                    transformers.extend(cols)
            return transformers

        feature_names = get_transformed_column_names(preprocessor, numeric_features, categorical_features)

        # ç»˜åˆ¶ summary plot
        shap.summary_plot(shap_values, X_train_dense, feature_names=feature_names, plot_type="bar")

    except Exception as e:
        print(f"âš ï¸ SHAP å›¾æ— æ³•ç”Ÿæˆï¼š{e}")

    print("âœ… æ•°æ®æ¢ç´¢æŠ¥å‘Šå·²å®Œæˆã€‚")
```

### 4. æ•°æ®é¢„å¤„ç†
æ•°æ®é¢„å¤„ç†è¿™å—ï¼šåŒ…æ‹¬ä½†ä¸é™äºæ•°æ®åŠ è½½ï¼Œç”Ÿæˆç‰¹å¾ï¼Œobjectç±»å‹ç¼–ç ï¼Œç¼ºå¤±å€¼å¤„ç†ï¼Œç›®æ ‡å€¼ç¼–ç ï¼Œåˆ‡åˆ†è®­ç»ƒé›†å’Œæµ‹è¯•é›†ï¼Œæ•°æ®æ ‡å‡†åŒ–...
è¿™é‡Œæˆ‘ç›´æ¥å§å…¨éƒ¨ä»£ç è´´å‡ºæ¥ï¼Œä¸å†åŒºåˆ†ã€‚
```python
# -----------------------------
# ç‰¹å¾æ„é€ 
# -----------------------------
def add_agricultural_features(df):
    """
    æ„é€ å†œä¸šé¢†åŸŸç›¸å…³ç‰¹å¾
    """
    df['NPK_Sum'] = df['Nitrogen'] + df['Phosphorous'] + df['Potassium']
    df['N_P_Ratio'] = df['Nitrogen'] / (df['Phosphorous'] + 1e-5)
    df['P_K_Ratio'] = df['Phosphorous'] / (df['Potassium'] + 1e-5)
    df['Env_Index'] = df['Temparature'] * df['Humidity'] * df['Moisture']
    df['Fertility_Score'] = (
            df['Nitrogen'] * 0.3 +
            df['Phosphorous'] * 0.3 +
            df['Potassium'] * 0.4
    )
    crop_n_preference = {
        'Wheat': 0.8,
        'Maize': 0.7,
        'Oil seeds': 0.3,
        'Paddy': 0.5,
        'Cotton': 0.6,
        'Barley': 0.7,
        'Millets': 0.5,
        'Sugarcane': 0.4,
        'Ground Nuts': 0.4,
        'Tobacco': 0.5,
        'Pulses': 0.4
    }
    df['Crop_Nitrogen_Preference'] = df['Crop Type'].map(crop_n_preference).fillna(0.5)
    df['Weighted_N'] = df['Nitrogen'] * df['Crop_Nitrogen_Preference']
    df['N_sqrt'] = np.sqrt(df['Nitrogen'])
    df['NK_ratio'] = df['Nitrogen'] / (df['Potassium'] + 1e-5)
    return df

def encode_and_transform(X, y=None, fit=False):
    """
    ä½¿ç”¨ ColumnTransformer ç¼–ç å¹¶æ ‡å‡†åŒ–ç‰¹å¾
    """
    categorical_cols = ['Soil Type', 'Crop Type']
    numerical_cols = ['Temparature', 'Humidity', 'Moisture', 'Nitrogen', 'Potassium', 'Phosphorous']
    agri_feature_cols = [col for col in X.columns if col not in categorical_cols + numerical_cols]

    from sklearn.compose import ColumnTransformer
    from sklearn.preprocessing import TargetEncoder, StandardScaler

    preprocessor = ColumnTransformer(
        transformers=[
            ('cat', TargetEncoder(), categorical_cols),
            ('num', StandardScaler(), numerical_cols + agri_feature_cols)
        ],
        remainder='passthrough'
    )

    if fit:
        X_processed = preprocessor.fit_transform(X, y)
        joblib.dump(preprocessor, SCALER_PATH)
    else:
        preprocessor = joblib.load(SCALER_PATH)
        X_processed = preprocessor.transform(X)

    return X_processed

def save_processed_data(df, filename='processed_train.csv'):
    """
    ä¿å­˜å¤„ç†åçš„DataFrameåˆ°CSVæ–‡ä»¶
    :param df: å¤„ç†åçš„DataFrame
    :param filename: è¾“å‡ºæ–‡ä»¶å
    """
    output_path = os.path.join(data_dir, filename)
    df.to_csv(output_path, index=False)
    print(f"âœ… å·²ä¿å­˜å¤„ç†åçš„æ•°æ®è‡³ {output_path}")

# -----------------------------
# æ•°æ®é¢„å¤„ç†ä¸ç¼–ç 
# -----------------------------
def preprocess_data(df, is_train=True):
    """
    å¯¹æ•°æ®è¿›è¡Œé¢„å¤„ç†ï¼ˆä»…ç”¨äºè®­ç»ƒï¼‰
    :param df: åŸå§‹ DataFrame
    :param is_train: æ˜¯å¦æ˜¯è®­ç»ƒæ•°æ®
    :return: å¤„ç†åçš„ç‰¹å¾çŸ©é˜µ X å’Œæ ‡ç­¾ y
    """
    df = add_agricultural_features(df)

    if is_train:
        X = df.drop(columns=['Fertilizer Name', 'id'])
        y = df['Fertilizer Name'].values
    else:
        X = df.drop(columns=['id'])
        y = None

    return X, y

def load_and_preprocess(data='train.csv'):
    file_path = os.path.join(DATA_DIR, data)
    df = pd.read_csv(file_path)
    X, y = preprocess_data(df, is_train=(data == 'train.csv'))

    le = LabelEncoder()
    y_encoded = le.fit_transform(y)
    joblib.dump(le, LABEL_ENCODER_PATH)

    X_processed = encode_and_transform(X, y_encoded, fit=True)

    feature_names = pd.DataFrame(X_processed).columns.tolist()
    df_processed = pd.DataFrame(X_processed, columns=feature_names)
    df_original = pd.read_csv(file_path)
    df_processed['Fertilizer Name'] = df_original['Fertilizer Name'].values
    save_processed_data(df_processed, 'processed_train.csv')

    X_train, X_val, y_train, y_val = train_test_split(X_processed, y_encoded, test_size=0.2, random_state=42,
                                                      stratify=y_encoded)
    return X_train, X_val, y_train, y_val, le.classes_

```

### 5. æ¨¡å‹é€‰æ‹©
åˆ°äº†è¿™ä¸€æ­¥å°±æ˜¯é€‰æ‹©æ¨¡å‹äº†ï¼Œæ ¹æ®æ•°æ®åˆ†ææ­¥éª¤ä¸­ï¼Œæˆ‘ä»¬å¤§æ¦‚å°±å·²ç»äº†è§£äº†æˆ‘ä»¬æœ¬æ¬¡çš„åˆ†ç±»ä»»åŠ¡ï¼Œé‚£ä¹ˆæ ¹æ®ä»€ä¹ˆå»é€‰æ‹©æ¨¡å‹å‘¢ï¼Ÿ
æˆ‘ä¸ªäººæ˜¯æ ¹æ®ä»¥ä¸‹å‡ ä¸ªå±‚çº§é€‰æ‹©æ¨¡å‹çš„ï¼š
1. å›å½’ä»»åŠ¡è¿˜æ˜¯åˆ†ç±»ä»»åŠ¡
2. æœ‰ç›‘ç£è¿˜æ˜¯æ— ç›‘ç£
3. æ•°æ®é‡ã€æ•°æ®è´¨é‡ã€æ¨¡å‹å¤æ‚åº¦ã€è®­ç»ƒæ—¶é—´ç­‰ç­‰

è¯´æ˜¯è¿™ä¹ˆè¯´ï¼Œä½†æ˜¯å®é™…é€‰æ‹©çš„æ—¶å€™è¯¸å¤šè®ºæ–‡å¤§ç‰›éƒ½å·²ç»å‘å¸ƒäº†å¾ˆå¤šæ¨¡å‹ï¼Œå¦‚æœæ ¹æ®å®é™…éœ€æ±‚å»é€‰æ‹©åˆé€‚çš„æ¨¡å‹ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªä¸ªè¯•ï¼Œè¿™ä¹Ÿæ˜¯è€ƒéªŒå·¥ç¨‹å¸ˆçš„æŠ€èƒ½ã€‚
æœ¬æ¬¡æ¨¡å‹æ•°æ®é‡ä¸€å…±æœ‰75000ï¼Œä¸å¤§ä¹Ÿä¸å°ï¼Œç”±äºæ˜¯åˆ†ç±»ä»»åŠ¡ï¼Œæ‰€ä»¥æˆ‘æ‹Ÿå®šä½¿ç”¨äº†XGBoostã€lightgbmã€catboostã€éšæœºæ£®æ—ã€mlpç­‰æ¨¡å‹ã€‚
æœ€ååŒæ ·çš„æ•°æ®ä¸‹é€‰æ‹©äº†æ•ˆæœæœ€é«˜çš„XGBoostï¼Œç„¶åé’ˆå¯¹è¿™ä¸€æ¨¡å‹è¿›è¡Œæ¨¡å‹è°ƒå‚ï¼Œæœ€åå°†ç»“æœä¿å­˜ä¸ºcsvæ–‡ä»¶ã€‚
è¿™å—ç›´æ¥è°ƒç”¨åº“å°±è¡Œäº†ã€‚
```python
print("XGBoost æ¨¡å‹è®­ç»ƒä¸­...")
clf = XGBClassifier(
    n_estimators=500,
    learning_rate=0.1,
    max_depth=5,
    min_child_weight=3,
    gamma=0.1,
    subsample=0.8,
    colsample_bytree=0.7,
    eval_metric='mlogloss',
    use_label_encoder=False,
    tree_method='hist'
)
eval_set = [(X_val, y_val)]
clf.fit(X_train, y_train, early_stopping_rounds=20, eval_set=eval_set, verbose=False)
print("XGBoostè®­ç»ƒç»“æŸ")
# # LightGBM ç¤ºä¾‹
# clf = LGBMClassifier(
#     n_estimators=1000,
#     learning_rate=0.05,
#     max_depth=6,
#     subsample=0.8,
#     colsample_bytree=0.8,
#     random_state=42
# )
y_pred = clf.predict(X_val)
print("Val Accuracy:", accuracy_score(y_val, y_pred))
print(classification_report(y_val, y_pred))
```

### 6. æ¨¡å‹ç»“æœåˆ†æ

è¿™é‡Œæ¨¡å‹ç»“æœåˆ†æä¸»è¦æ˜¯æ¨¡å‹çš„æ€§èƒ½æŒ‡æ ‡ï¼ˆå‡†ç¡®ç‡ã€ç²¾å‡†ç‡ã€å¬å›ç‡ã€F1åˆ†æ•°ç­‰ï¼‰ã€ç±»åˆ«åˆ†ç±»æŠ¥å‘Šã€æ¨¡å‹é¢„æµ‹ç»“æœçš„æ··æ·†çŸ©é˜µçƒ­åŠ›å›¾ç­‰ã€‚
é€šè¿‡è¿™äº›æ•°æ®çŸ¥é“è‡ªå·±è®­ç»ƒå‡ºæ¥çš„æ¨¡å‹å“ªäº›ç±»åˆ«ç‰¹åˆ«å¼ºï¼Œå“ªäº›ç±»åˆ«ç‰¹åˆ«å¼±ç­‰ç­‰ã€‚
ç„¶åæ ¹æ®è¿™äº›æ•°æ®å†æ‰è¿‡å¤´æ¥æ•°æ®åˆ†æã€ç‰¹å¾å·¥ç¨‹ã€æ•°æ®åŠ å·¥å†æ¥ä¸€éã€‚

### æŸ¥çœ‹è®­ç»ƒæƒ…å†µ
```shell
tensorboard --logdir={#path_to_your_logs}
```